import os
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_qdrant import QdrantVectorStore
from qdrant_client import QdrantClient, models
from langchain_community.vectorstores import Chroma
from langchain_community.document_loaders import TextLoader
from langchain_community.vectorstores import FAISS
from langchain_community.docstore.in_memory import InMemoryDocstore
from langchain.text_splitter import RecursiveCharacterTextSplitter
import PyPDF2
import faiss  # pylint: disable=import-error


os.environ["PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION"] = "cpp"
# multi-qa-mpnet-base-dot-v1
# sentence-transformers/all-mpnet-base-v2
# facebook/dpr-question_encoder-single-nq-base
# mixedbread-ai/mxbai-embed-large-v1
# sentence-transformers/all-MiniLM-L6-v2


class OpenEmbedder:
    def __init__(
        self,
        embedding_model_name: str = "mixedbread-ai/mxbai-embed-large-v1",
        vectordb_name: str = "chromadb",
        collection_name: str = "my_collection",
        qdrant_url: str = "http://0.0.0.0:6333",
    ):
        """
         The OpenEmbedder class is designed to facilitate the creation and querying
         of persistent vector databases using embeddings generated by HuggingFace
         models. Users can specify an embedding model, select a vector database
        (either ChromaDB or Qdrant), and define a collection name for storing embeddings.
         The class supports initializing an existing database or creating a new one
         from a text file, ensuring that the vector database is stored persistently
         on disk. It also provides functionality for querying the database
         using natural language, making it a versatile tool for retrieval-augmented
         generation (RAG) and other NLP applications.

         Args:
             embedding_model_name (str, optional): The name or ID of the HuggingFace
             embedding model to be used. Defaults to 'sentence-transformers/all-MiniLM-L6-v2'.
             vectordb_name (str, optional): The name of the vector database to use. It
             can be either 'chromadb' for Chroma or 'qdrant' for Qdrant. Defaults to 'chromadb'.
             collection_name (str, optional):  The name of the collection within the
             vector database where the embeddings will be stored. Defaults to 'my_collection'.
             persist_directory (str, optional):  The directory path where ChromaDB will
             persistently store vectors.. Defaults to "./chromadb_store".
             qdrant_url (_type_, optional):The URL of the Qdrant database to connect to.
             This parameter is used only when Qdrant is selected as the vector database.
             Defaults to "http://localhost:6333".
        """

        # self.embedding_model_name = embedding_model_name
        self.vectordb_name = vectordb_name.lower()
        self.collection_name = collection_name
        self.persist_directory = self._get_persist_dirname()
        self.qdrant_url = qdrant_url
        self.embeddings = HuggingFaceEmbeddings(
            model_name=embedding_model_name, model_kwargs={"trust_remote_code": True}
        )
        self.index = faiss.IndexFlatL2(self._get_embedding_size())

        # Ensure the persistence directory exists
        os.makedirs(self.persist_directory, exist_ok=True)

        # Initialize vector database
        self.vectordb = self._initialize_vectordb()

    def _get_persist_dirname(self) -> str:
        if self.vectordb_name == "chromadb":
            return "./chromadb_store"
        if self.vectordb_name == "faiss":
            return "./faiss_store"
        if self.vectordb_name == "qdrant":
            return "./qdrant_store"
        return ""

    def _get_embedding_size(self) -> int:
        """return size of embedding

        Returns:
            int: embedding size for selected embedding model
        """
        return len(self.embeddings.embed_query("hello world"))

    def _initialize_vectordb(self):

        if self.vectordb_name == "chromadb":
            vectordb = Chroma(
                persist_directory=self.persist_directory,
                embedding_function=self.embeddings,
                collection_name=self.collection_name,
            )

        elif self.vectordb_name == "qdrant":
            try:
                # create client for qdrant database
                client = QdrantClient(url=self.qdrant_url)
                existing_collections = client.get_collections().collections

                # if collection does not exists create collection
                if self.collection_name not in [
                    col.name for col in existing_collections
                ]:
                    # Create the collection
                    print("creating collection....")
                    client.create_collection(
                        collection_name=self.collection_name,
                        vectors_config=models.VectorParams(
                            size=self._get_embedding_size(),
                            distance=models.Distance.COSINE,
                        ),
                    )
                vectordb = QdrantVectorStore(
                    client=client,
                    collection_name=self.collection_name,
                    embedding=self.embeddings,
                )
            except Exception as e:
                print(f"Error initializing qdrant vectordb: {e}")
                raise ValueError(
                    f"Please make sure qdrant db is running on port 6333: {str(e)}"
                ) from e

        elif self.vectordb_name == "faiss":
            faiss_index_file = os.path.join(
                self.persist_directory, f"{self.collection_name}_faiss.index.faiss"
            )
            vectordb = None
            if os.path.exists(faiss_index_file):
                # Load the existing FAISS index
                vectordb = FAISS.load_local(
                    folder_path=self.persist_directory,
                    embeddings=self.embeddings,
                    index_name=f"{self.collection_name}_faiss.index",
                    allow_dangerous_deserialization=True,
                )
                self.vectordb = vectordb
                print(f"Loaded FAISS index from {faiss_index_file}")
        else:
            raise ValueError(f"Unsupported vector database: {self.vectordb_name}")
        return vectordb

    def extract_text_from_pdf(self, pdf_file):
        reader = PyPDF2.PdfReader(pdf_file)
        text = ""
        for _, page in enumerate(reader.pages):  # Use enumerate for iteration
            text += page.extract_text()  # Access the page directly
        return text

    def create_database(self, text_file_path: str):

        # Load and split the document
        loader = TextLoader(text_file_path, encoding="utf-8")
        documents = loader.load()
        splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=100)
        texts = splitter.split_documents(documents)

        # Add documents to the vector database
        if self.vectordb_name == "faiss":
            faiss_index_file = os.path.join(
                self.persist_directory, f"{self.collection_name}_faiss.index"
            )
            index_to_docstore_id = (
                {}
            )  # Initialize an empty mapping for the document IDs
            vectordb = FAISS(
                embedding_function=self.embeddings,
                index=self.index,
                docstore=InMemoryDocstore({}),
                index_to_docstore_id=index_to_docstore_id,
            )
            self.vectordb = vectordb
            # Use the existing FAISS index instance
            self.vectordb.add_documents(texts)
            self.vectordb.save_local(
                folder_path=self.persist_directory,
                index_name=f"{self.collection_name}_faiss.index",
            )
            print(f"FAISS index saved to {faiss_index_file}")
        elif self.vectordb_name == "chromadb":
            # ChromaDB-specific document addition
            self.vectordb.add_documents(texts)

        elif self.vectordb_name == "qdrant":
            # Qdrant-specific document addition
            self.vectordb.add_documents(texts)
        else:
            raise ValueError(f"Unsupported vector database: {self.vectordb_name}")

    def query_database(self, query: str, k: int = 5):
        results = self.vectordb.similarity_search(query, k=k)
        return results
